(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{347:function(e,t,i){"use strict";i.r(t);var s=i(25),a=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"设计模式-数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计模式-数据结构"}},[e._v("#")]),e._v(" 设计模式 + 数据结构")]),e._v(" "),t("h2",{attrs:{id:"设计原则solid"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计原则solid"}},[e._v("#")]),e._v(" 设计原则SOLID")]),e._v(" "),t("p",[e._v("支持多人协作的、易于理解的、易读的、可测试的代码")]),e._v(" "),t("h3",{attrs:{id:"s-srp-single-responsibility-principle-单一职责原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#s-srp-single-responsibility-principle-单一职责原则"}},[e._v("#")]),e._v(" S: SRP single responsibility principle 单一职责原则")]),e._v(" "),t("p",[e._v("定义：一个类应该只有一个引起它变化的原因。")]),e._v(" "),t("ul",[t("li",[e._v("每个类只负责一项职责")]),e._v(" "),t("li",[e._v("减少类之间的耦合")]),e._v(" "),t("li",[e._v("提高代码的可读性和可维护性")])]),e._v(" "),t("h3",{attrs:{id:"o-open-closed-principle-开闭原则-软件实体-对扩展开放-对修改关闭-eg-vue源码的插件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#o-open-closed-principle-开闭原则-软件实体-对扩展开放-对修改关闭-eg-vue源码的插件"}},[e._v("#")]),e._v(" O: open closed principle 开闭原则 （软件实体， 对扩展开放，对修改关闭） eg: Vue源码的插件")]),e._v(" "),t("p",[e._v("定义：软件实体（类、模块、函数等）应该对扩展开发，对修改关闭。")]),e._v(" "),t("ul",[t("li",[e._v("通过扩展而不是修改现有代码来添加新功能")]),e._v(" "),t("li",[e._v("使用抽象和接口来实现这一原则")])]),e._v(" "),t("h3",{attrs:{id:"l-liskov-substitution-principle-里式替代原则-子类可以替换掉父类-eg-看起来像java的多态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#l-liskov-substitution-principle-里式替代原则-子类可以替换掉父类-eg-看起来像java的多态"}},[e._v("#")]),e._v(" L: Liskov Substitution principle 里式替代原则（子类可以替换掉父类）eg: 看起来像Java的多态")]),e._v(" "),t("h3",{attrs:{id:"i-interface-segregation-principle-接口隔离原则-原子化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#i-interface-segregation-principle-接口隔离原则-原子化"}},[e._v("#")]),e._v(" I: interface segregation principle 接口隔离原则（原子化）")]),e._v(" "),t("h3",{attrs:{id:"d-dependence-inversion-principle-依赖倒置原则-eg-爷孙的通信-usecontext-provide-inject"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#d-dependence-inversion-principle-依赖倒置原则-eg-爷孙的通信-usecontext-provide-inject"}},[e._v("#")]),e._v(" D: dependence inversion principle 依赖倒置原则 eg: 爷孙的通信 useContext provide inject")]),e._v(" "),t("h2",{attrs:{id:"设计模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[e._v("#")]),e._v(" 设计模式")]),e._v(" "),t("p",[e._v("设计模式 是软件开发的经典解决方案。")]),e._v(" "),t("h3",{attrs:{id:"创建型模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建型模式"}},[e._v("#")]),e._v(" 创建型模式")]),e._v(" "),t("p",[e._v("增强 已有代码的灵活性")]),e._v(" "),t("h4",{attrs:{id:"单例模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单例模式"}},[e._v("#")]),e._v(" 单例模式")]),e._v(" "),t("p",[e._v("每个类都只有一个实例。eg: loading")]),e._v(" "),t("h3",{attrs:{id:"结构型模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结构型模式"}},[e._v("#")]),e._v(" 结构型模式")]),e._v(" "),t("p",[e._v("将 不同代码 解耦")]),e._v(" "),t("h3",{attrs:{id:"行为模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#行为模式"}},[e._v("#")]),e._v(" 行为模式")]),e._v(" "),t("p",[e._v("不同的行为 解耦")])])}),[],!1,null,null,null);t.default=a.exports}}]);