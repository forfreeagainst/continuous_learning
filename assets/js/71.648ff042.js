(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{392:function(t,a,e){"use strict";e.r(a);var r=e(25),s=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"react源码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react源码"}},[t._v("#")]),t._v(" React源码")]),t._v(" "),a("h2",{attrs:{id:"已学进度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#已学进度"}},[t._v("#")]),t._v(" 已学进度")]),t._v(" "),a("p",[t._v("1-1，2-1")]),t._v(" "),a("h2",{attrs:{id:"为什么要学习react源码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要学习react源码"}},[t._v("#")]),t._v(" 为什么要学习React源码")]),t._v(" "),a("h3",{attrs:{id:"解决常见面试题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决常见面试题"}},[t._v("#")]),t._v(" 解决常见面试题")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("为什么不能在循环，条件 或者 嵌套函数中调用 Hook")])]),t._v(" "),a("li",[a("p",[t._v("为什么 Hook 出现之后，函数组件中可以定义 state，保存在了哪里")])]),t._v(" "),a("li",[a("p",[t._v("React / Vue DIFF 算法")])])]),t._v(" "),a("p",[t._v("Vue是数组，可以双向查找。React是单链表，使用单向查找。")]),t._v(" "),a("h3",{attrs:{id:"优化项目"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优化项目"}},[t._v("#")]),t._v(" 优化项目")]),t._v(" "),a("ul",[a("li",[t._v("了解 React运行机制，提升项目性能，如合理使用缓存、尽可能避免组件的无效渲染等。")]),t._v(" "),a("li",[t._v("具体措施：保证组件key 取值的稳定性、适时使用 useCallback、useMemo、memo等API，掌握React中\n状态的管理方式，掌握effect的使用时机等。")])]),t._v(" "),a("h3",{attrs:{id:"提高个人编码水平"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#提高个人编码水平"}},[t._v("#")]),t._v(" 提高个人编码水平")]),t._v(" "),a("p",[t._v("React的那些学习知识点")]),t._v(" "),a("p",[t._v("VDom、Fiber、单链表、循环列表、最小堆、单线程任务调度器、位运算、哈希表、深度优化搜索、栈与队列等等。")]),t._v(" "),a("h2",{attrs:{id:"react的迭代历史"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react的迭代历史"}},[t._v("#")]),t._v(" React的迭代历史")]),t._v(" "),a("h3",{attrs:{id:"_16-3-引入fiber架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_16-3-引入fiber架构"}},[t._v("#")]),t._v(" 16.3: 引入fiber架构")]),t._v(" "),a("h3",{attrs:{id:"_16-8-正式引入hooks。-这条很重要-一定要能说出来"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_16-8-正式引入hooks。-这条很重要-一定要能说出来"}},[t._v("#")]),t._v(" 16.8：正式引入hooks。（这条很重要，一定要能说出来）")]),t._v(" "),a("h3",{attrs:{id:"_17-垫脚石版本"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_17-垫脚石版本"}},[t._v("#")]),t._v(" 17: 垫脚石版本")]),t._v(" "),a("ul",[a("li",[t._v("全新的JSX转换，在React17以前 ，使用JSX语法，必须要导入React,否则会报错。这是因为旧的 JSX 转换会把 JSX 转换为 React.createElement(...) 调用。")])]),t._v(" "),a("p",[t._v("React.createElement和vue的h很相似吧，React.createElement 和 Vue 的 h 函数非常相似，它们都是用于创建虚拟 DOM 元素的底层 API。")]),t._v(" "),a("ul",[a("li",[t._v("事件委托的变更，不再委托在document，而是组件的最顶层。")]),t._v(" "),a("li",[t._v("副作用清理事件")]),t._v(" "),a("li",[t._v("返回一致的 undefined错误")])]),t._v(" "),a("h3",{attrs:{id:"_18-大量新特性出现-如自动批量处理、非紧急更新、concurrent等。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_18-大量新特性出现-如自动批量处理、非紧急更新、concurrent等。"}},[t._v("#")]),t._v(" 18：大量新特性出现，如自动批量处理、非紧急更新、Concurrent等。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("setState 变成自动批量更新，是异步。如果想同步的话，用flushSync")])]),t._v(" "),a("li",[a("p",[t._v("transition的API: startTransition、useTransition、useDeferedValue")])]),t._v(" "),a("li",[a("p",[t._v("...")])])]),t._v(" "),a("h2",{attrs:{id:"thinking-in-react-react哲学"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#thinking-in-react-react哲学"}},[t._v("#")]),t._v(" Thinking in React（React哲学）")]),t._v(" "),a("h2",{attrs:{id:"其他"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[t._v("#")]),t._v(" 其他")]),t._v(" "),a("p",[t._v("jsx => react/jsx-runtime")])])}),[],!1,null,null,null);a.default=s.exports}}]);